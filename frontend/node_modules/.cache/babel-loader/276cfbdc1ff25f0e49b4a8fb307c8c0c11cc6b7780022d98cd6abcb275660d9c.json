{"ast":null,"code":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\nconst ctorRegistry = utils.ctorRegistrySymbol;\nconst IteratorPrototype = Object.create(utils.IteratorPrototype, {\n  next: {\n    value: function next() {\n      const internal = this[utils.iterInternalSymbol];\n      const {\n        target,\n        kind,\n        index\n      } = internal;\n      const values = Array.from(target[impl]);\n      const len = values.length;\n      if (index >= len) {\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n      const pair = values[index];\n      internal.index = index + 1;\n      const [key, value] = pair.map(utils.tryWrapperForImpl);\n      let result;\n      switch (kind) {\n        case \"key\":\n          result = key;\n          break;\n        case \"value\":\n          result = value;\n          break;\n        case \"key+value\":\n          result = [key, value];\n          break;\n      }\n      return {\n        value: result,\n        done: false\n      };\n    },\n    writable: true,\n    enumerable: true,\n    configurable: true\n  },\n  [Symbol.toStringTag]: {\n    value: \"URLSearchParams Iterator\",\n    configurable: true\n  }\n});\nconst iface = {\n  // When an interface-module that implements this interface as a mixin is loaded, it will append its own `.is()`\n  // method into this array. It allows objects that directly implements *those* interfaces to be recognized as\n  // implementing this mixin interface.\n  _mixedIntoPredicates: [],\n  is(obj) {\n    if (obj) {\n      if (utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (const isMixedInto of module.exports._mixedIntoPredicates) {\n        if (isMixedInto(obj)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n      const wrapper = utils.wrapperForImpl(obj);\n      for (const isMixedInto of module.exports._mixedIntoPredicates) {\n        if (isMixedInto(wrapper)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  convert(obj, {\n    context = \"The provided value\"\n  } = {}) {\n    if (module.exports.is(obj)) {\n      return utils.implForWrapper(obj);\n    }\n    throw new TypeError(`${context} is not of type 'URLSearchParams'.`);\n  },\n  createDefaultIterator(target, kind) {\n    const iterator = Object.create(IteratorPrototype);\n    Object.defineProperty(iterator, utils.iterInternalSymbol, {\n      value: {\n        target,\n        kind,\n        index: 0\n      },\n      configurable: true\n    });\n    return iterator;\n  },\n  create(globalObject, constructorArgs, privateData) {\n    if (globalObject[ctorRegistry] === undefined) {\n      throw new Error(\"Internal error: invalid global object\");\n    }\n    const ctor = globalObject[ctorRegistry][\"URLSearchParams\"];\n    if (ctor === undefined) {\n      throw new Error(\"Internal error: constructor URLSearchParams is not installed on the passed global object\");\n    }\n    let obj = Object.create(ctor.prototype);\n    obj = iface.setup(obj, globalObject, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(globalObject, constructorArgs, privateData) {\n    const obj = iface.create(globalObject, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {},\n  setup(obj, globalObject, constructorArgs = [], privateData = {}) {\n    privateData.wrapper = obj;\n    iface._internalSetup(obj);\n    Object.defineProperty(obj, impl, {\n      value: new Impl.implementation(globalObject, constructorArgs, privateData),\n      configurable: true\n    });\n    obj[impl][utils.wrapperSymbol] = obj;\n    if (Impl.init) {\n      Impl.init(obj[impl], privateData);\n    }\n    return obj;\n  },\n  install(globalObject) {\n    class URLSearchParams {\n      constructor() {\n        const args = [];\n        {\n          let curArg = arguments[0];\n          if (curArg !== undefined) {\n            if (utils.isObject(curArg)) {\n              if (curArg[Symbol.iterator] !== undefined) {\n                if (!utils.isObject(curArg)) {\n                  throw new TypeError(\"Failed to construct 'URLSearchParams': parameter 1\" + \" sequence\" + \" is not an iterable object.\");\n                } else {\n                  const V = [];\n                  const tmp = curArg;\n                  for (let nextItem of tmp) {\n                    if (!utils.isObject(nextItem)) {\n                      throw new TypeError(\"Failed to construct 'URLSearchParams': parameter 1\" + \" sequence\" + \"'s element\" + \" is not an iterable object.\");\n                    } else {\n                      const V = [];\n                      const tmp = nextItem;\n                      for (let nextItem of tmp) {\n                        nextItem = conversions[\"USVString\"](nextItem, {\n                          context: \"Failed to construct 'URLSearchParams': parameter 1\" + \" sequence\" + \"'s element\" + \"'s element\"\n                        });\n                        V.push(nextItem);\n                      }\n                      nextItem = V;\n                    }\n                    V.push(nextItem);\n                  }\n                  curArg = V;\n                }\n              } else {\n                if (!utils.isObject(curArg)) {\n                  throw new TypeError(\"Failed to construct 'URLSearchParams': parameter 1\" + \" record\" + \" is not an object.\");\n                } else {\n                  const result = Object.create(null);\n                  for (const key of Reflect.ownKeys(curArg)) {\n                    const desc = Object.getOwnPropertyDescriptor(curArg, key);\n                    if (desc && desc.enumerable) {\n                      let typedKey = key;\n                      typedKey = conversions[\"USVString\"](typedKey, {\n                        context: \"Failed to construct 'URLSearchParams': parameter 1\" + \" record\" + \"'s key\"\n                      });\n                      let typedValue = curArg[key];\n                      typedValue = conversions[\"USVString\"](typedValue, {\n                        context: \"Failed to construct 'URLSearchParams': parameter 1\" + \" record\" + \"'s value\"\n                      });\n                      result[typedKey] = typedValue;\n                    }\n                  }\n                  curArg = result;\n                }\n              }\n            } else {\n              curArg = conversions[\"USVString\"](curArg, {\n                context: \"Failed to construct 'URLSearchParams': parameter 1\"\n              });\n            }\n          } else {\n            curArg = \"\";\n          }\n          args.push(curArg);\n        }\n        return iface.setup(Object.create(this.constructor.prototype), globalObject, args);\n      }\n      append(name, value) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 2) {\n          throw new TypeError(\"Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only \" + arguments.length + \" present.\");\n        }\n        const args = [];\n        {\n          let curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'append' on 'URLSearchParams': parameter 1\"\n          });\n          args.push(curArg);\n        }\n        {\n          let curArg = arguments[1];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'append' on 'URLSearchParams': parameter 2\"\n          });\n          args.push(curArg);\n        }\n        return this[impl].append(...args);\n      }\n      delete(name) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\"Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only \" + arguments.length + \" present.\");\n        }\n        const args = [];\n        {\n          let curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'delete' on 'URLSearchParams': parameter 1\"\n          });\n          args.push(curArg);\n        }\n        return this[impl].delete(...args);\n      }\n      get(name) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\"Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only \" + arguments.length + \" present.\");\n        }\n        const args = [];\n        {\n          let curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'get' on 'URLSearchParams': parameter 1\"\n          });\n          args.push(curArg);\n        }\n        return this[impl].get(...args);\n      }\n      getAll(name) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\"Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only \" + arguments.length + \" present.\");\n        }\n        const args = [];\n        {\n          let curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'getAll' on 'URLSearchParams': parameter 1\"\n          });\n          args.push(curArg);\n        }\n        return utils.tryWrapperForImpl(this[impl].getAll(...args));\n      }\n      has(name) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\"Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only \" + arguments.length + \" present.\");\n        }\n        const args = [];\n        {\n          let curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'has' on 'URLSearchParams': parameter 1\"\n          });\n          args.push(curArg);\n        }\n        return this[impl].has(...args);\n      }\n      set(name, value) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 2) {\n          throw new TypeError(\"Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only \" + arguments.length + \" present.\");\n        }\n        const args = [];\n        {\n          let curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'set' on 'URLSearchParams': parameter 1\"\n          });\n          args.push(curArg);\n        }\n        {\n          let curArg = arguments[1];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'set' on 'URLSearchParams': parameter 2\"\n          });\n          args.push(curArg);\n        }\n        return this[impl].set(...args);\n      }\n      sort() {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[impl].sort();\n      }\n      toString() {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return this[impl].toString();\n      }\n      keys() {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return module.exports.createDefaultIterator(this, \"key\");\n      }\n      values() {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return module.exports.createDefaultIterator(this, \"value\");\n      }\n      entries() {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return module.exports.createDefaultIterator(this, \"key+value\");\n      }\n      forEach(callback) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\"Failed to execute 'forEach' on 'iterable': 1 argument required, \" + \"but only 0 present.\");\n        }\n        if (typeof callback !== \"function\") {\n          throw new TypeError(\"Failed to execute 'forEach' on 'iterable': The callback provided \" + \"as parameter 1 is not a function.\");\n        }\n        const thisArg = arguments[1];\n        let pairs = Array.from(this[impl]);\n        let i = 0;\n        while (i < pairs.length) {\n          const [key, value] = pairs[i].map(utils.tryWrapperForImpl);\n          callback.call(thisArg, value, key, this);\n          pairs = Array.from(this[impl]);\n          i++;\n        }\n      }\n    }\n    Object.defineProperties(URLSearchParams.prototype, {\n      append: {\n        enumerable: true\n      },\n      delete: {\n        enumerable: true\n      },\n      get: {\n        enumerable: true\n      },\n      getAll: {\n        enumerable: true\n      },\n      has: {\n        enumerable: true\n      },\n      set: {\n        enumerable: true\n      },\n      sort: {\n        enumerable: true\n      },\n      toString: {\n        enumerable: true\n      },\n      keys: {\n        enumerable: true\n      },\n      values: {\n        enumerable: true\n      },\n      entries: {\n        enumerable: true\n      },\n      forEach: {\n        enumerable: true\n      },\n      [Symbol.toStringTag]: {\n        value: \"URLSearchParams\",\n        configurable: true\n      },\n      [Symbol.iterator]: {\n        value: URLSearchParams.prototype.entries,\n        configurable: true,\n        writable: true\n      }\n    });\n    if (globalObject[ctorRegistry] === undefined) {\n      globalObject[ctorRegistry] = Object.create(null);\n    }\n    globalObject[ctorRegistry][\"URLSearchParams\"] = URLSearchParams;\n    Object.defineProperty(globalObject, \"URLSearchParams\", {\n      configurable: true,\n      writable: true,\n      value: URLSearchParams\n    });\n  }\n};\n// iface\nmodule.exports = iface;\nconst Impl = require(\"./URLSearchParams-impl.js\");","map":{"version":3,"names":["conversions","require","utils","impl","implSymbol","ctorRegistry","ctorRegistrySymbol","IteratorPrototype","Object","create","next","value","internal","iterInternalSymbol","target","kind","index","values","Array","from","len","length","undefined","done","pair","key","map","tryWrapperForImpl","result","writable","enumerable","configurable","Symbol","toStringTag","iface","_mixedIntoPredicates","is","obj","hasOwn","Impl","implementation","isMixedInto","module","exports","isImpl","wrapper","wrapperForImpl","convert","context","implForWrapper","TypeError","createDefaultIterator","iterator","defineProperty","globalObject","constructorArgs","privateData","Error","ctor","prototype","setup","createImpl","_internalSetup","wrapperSymbol","init","install","URLSearchParams","constructor","args","curArg","arguments","isObject","V","tmp","nextItem","push","Reflect","ownKeys","desc","getOwnPropertyDescriptor","typedKey","typedValue","append","name","delete","get","getAll","has","set","sort","toString","keys","entries","forEach","callback","thisArg","pairs","i","call","defineProperties"],"sources":["/Users/jonathon/.yarn/berry/cache/whatwg-url-without-unicode-npm-8.0.0-3-d98937d586-10c0.zip/node_modules/whatwg-url-without-unicode/lib/URLSearchParams.js"],"sourcesContent":["\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst impl = utils.implSymbol;\nconst ctorRegistry = utils.ctorRegistrySymbol;\n\nconst IteratorPrototype = Object.create(utils.IteratorPrototype, {\n  next: {\n    value: function next() {\n      const internal = this[utils.iterInternalSymbol];\n      const { target, kind, index } = internal;\n      const values = Array.from(target[impl]);\n      const len = values.length;\n      if (index >= len) {\n        return { value: undefined, done: true };\n      }\n\n      const pair = values[index];\n      internal.index = index + 1;\n      const [key, value] = pair.map(utils.tryWrapperForImpl);\n\n      let result;\n      switch (kind) {\n        case \"key\":\n          result = key;\n          break;\n        case \"value\":\n          result = value;\n          break;\n        case \"key+value\":\n          result = [key, value];\n          break;}\n\n      return { value: result, done: false };\n    },\n    writable: true,\n    enumerable: true,\n    configurable: true },\n\n  [Symbol.toStringTag]: {\n    value: \"URLSearchParams Iterator\",\n    configurable: true } });\n\n\n\nconst iface = {\n  // When an interface-module that implements this interface as a mixin is loaded, it will append its own `.is()`\n  // method into this array. It allows objects that directly implements *those* interfaces to be recognized as\n  // implementing this mixin interface.\n  _mixedIntoPredicates: [],\n  is(obj) {\n    if (obj) {\n      if (utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (const isMixedInto of module.exports._mixedIntoPredicates) {\n        if (isMixedInto(obj)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (const isMixedInto of module.exports._mixedIntoPredicates) {\n        if (isMixedInto(wrapper)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  convert(obj, { context = \"The provided value\" } = {}) {\n    if (module.exports.is(obj)) {\n      return utils.implForWrapper(obj);\n    }\n    throw new TypeError(`${context} is not of type 'URLSearchParams'.`);\n  },\n\n  createDefaultIterator(target, kind) {\n    const iterator = Object.create(IteratorPrototype);\n    Object.defineProperty(iterator, utils.iterInternalSymbol, {\n      value: { target, kind, index: 0 },\n      configurable: true });\n\n    return iterator;\n  },\n\n  create(globalObject, constructorArgs, privateData) {\n    if (globalObject[ctorRegistry] === undefined) {\n      throw new Error(\"Internal error: invalid global object\");\n    }\n\n    const ctor = globalObject[ctorRegistry][\"URLSearchParams\"];\n    if (ctor === undefined) {\n      throw new Error(\"Internal error: constructor URLSearchParams is not installed on the passed global object\");\n    }\n\n    let obj = Object.create(ctor.prototype);\n    obj = iface.setup(obj, globalObject, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(globalObject, constructorArgs, privateData) {\n    const obj = iface.create(globalObject, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {},\n  setup(obj, globalObject, constructorArgs = [], privateData = {}) {\n    privateData.wrapper = obj;\n\n    iface._internalSetup(obj);\n    Object.defineProperty(obj, impl, {\n      value: new Impl.implementation(globalObject, constructorArgs, privateData),\n      configurable: true });\n\n\n    obj[impl][utils.wrapperSymbol] = obj;\n    if (Impl.init) {\n      Impl.init(obj[impl], privateData);\n    }\n    return obj;\n  },\n\n  install(globalObject) {\n    class URLSearchParams {\n      constructor() {\n        const args = [];\n        {\n          let curArg = arguments[0];\n          if (curArg !== undefined) {\n            if (utils.isObject(curArg)) {\n              if (curArg[Symbol.iterator] !== undefined) {\n                if (!utils.isObject(curArg)) {\n                  throw new TypeError(\n                  \"Failed to construct 'URLSearchParams': parameter 1\" + \" sequence\" + \" is not an iterable object.\");\n\n                } else {\n                  const V = [];\n                  const tmp = curArg;\n                  for (let nextItem of tmp) {\n                    if (!utils.isObject(nextItem)) {\n                      throw new TypeError(\n                      \"Failed to construct 'URLSearchParams': parameter 1\" +\n                      \" sequence\" +\n                      \"'s element\" +\n                      \" is not an iterable object.\");\n\n                    } else {\n                      const V = [];\n                      const tmp = nextItem;\n                      for (let nextItem of tmp) {\n                        nextItem = conversions[\"USVString\"](nextItem, {\n                          context:\n                          \"Failed to construct 'URLSearchParams': parameter 1\" +\n                          \" sequence\" +\n                          \"'s element\" +\n                          \"'s element\" });\n\n\n                        V.push(nextItem);\n                      }\n                      nextItem = V;\n                    }\n\n                    V.push(nextItem);\n                  }\n                  curArg = V;\n                }\n              } else {\n                if (!utils.isObject(curArg)) {\n                  throw new TypeError(\n                  \"Failed to construct 'URLSearchParams': parameter 1\" + \" record\" + \" is not an object.\");\n\n                } else {\n                  const result = Object.create(null);\n                  for (const key of Reflect.ownKeys(curArg)) {\n                    const desc = Object.getOwnPropertyDescriptor(curArg, key);\n                    if (desc && desc.enumerable) {\n                      let typedKey = key;\n\n                      typedKey = conversions[\"USVString\"](typedKey, {\n                        context: \"Failed to construct 'URLSearchParams': parameter 1\" + \" record\" + \"'s key\" });\n\n\n                      let typedValue = curArg[key];\n\n                      typedValue = conversions[\"USVString\"](typedValue, {\n                        context: \"Failed to construct 'URLSearchParams': parameter 1\" + \" record\" + \"'s value\" });\n\n\n                      result[typedKey] = typedValue;\n                    }\n                  }\n                  curArg = result;\n                }\n              }\n            } else {\n              curArg = conversions[\"USVString\"](curArg, {\n                context: \"Failed to construct 'URLSearchParams': parameter 1\" });\n\n            }\n          } else {\n            curArg = \"\";\n          }\n          args.push(curArg);\n        }\n        return iface.setup(Object.create(this.constructor.prototype), globalObject, args);\n      }\n\n      append(name, value) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n\n        if (arguments.length < 2) {\n          throw new TypeError(\n          \"Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only \" +\n          arguments.length +\n          \" present.\");\n\n        }\n        const args = [];\n        {\n          let curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'append' on 'URLSearchParams': parameter 1\" });\n\n          args.push(curArg);\n        }\n        {\n          let curArg = arguments[1];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'append' on 'URLSearchParams': parameter 2\" });\n\n          args.push(curArg);\n        }\n        return this[impl].append(...args);\n      }\n\n      delete(name) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n\n        if (arguments.length < 1) {\n          throw new TypeError(\n          \"Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only \" +\n          arguments.length +\n          \" present.\");\n\n        }\n        const args = [];\n        {\n          let curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'delete' on 'URLSearchParams': parameter 1\" });\n\n          args.push(curArg);\n        }\n        return this[impl].delete(...args);\n      }\n\n      get(name) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n\n        if (arguments.length < 1) {\n          throw new TypeError(\n          \"Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only \" +\n          arguments.length +\n          \" present.\");\n\n        }\n        const args = [];\n        {\n          let curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'get' on 'URLSearchParams': parameter 1\" });\n\n          args.push(curArg);\n        }\n        return this[impl].get(...args);\n      }\n\n      getAll(name) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n\n        if (arguments.length < 1) {\n          throw new TypeError(\n          \"Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only \" +\n          arguments.length +\n          \" present.\");\n\n        }\n        const args = [];\n        {\n          let curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'getAll' on 'URLSearchParams': parameter 1\" });\n\n          args.push(curArg);\n        }\n        return utils.tryWrapperForImpl(this[impl].getAll(...args));\n      }\n\n      has(name) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n\n        if (arguments.length < 1) {\n          throw new TypeError(\n          \"Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only \" +\n          arguments.length +\n          \" present.\");\n\n        }\n        const args = [];\n        {\n          let curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'has' on 'URLSearchParams': parameter 1\" });\n\n          args.push(curArg);\n        }\n        return this[impl].has(...args);\n      }\n\n      set(name, value) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n\n        if (arguments.length < 2) {\n          throw new TypeError(\n          \"Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only \" +\n          arguments.length +\n          \" present.\");\n\n        }\n        const args = [];\n        {\n          let curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'set' on 'URLSearchParams': parameter 1\" });\n\n          args.push(curArg);\n        }\n        {\n          let curArg = arguments[1];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'set' on 'URLSearchParams': parameter 2\" });\n\n          args.push(curArg);\n        }\n        return this[impl].set(...args);\n      }\n\n      sort() {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n\n        return this[impl].sort();\n      }\n\n      toString() {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n\n        return this[impl].toString();\n      }\n\n      keys() {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return module.exports.createDefaultIterator(this, \"key\");\n      }\n\n      values() {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return module.exports.createDefaultIterator(this, \"value\");\n      }\n\n      entries() {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        return module.exports.createDefaultIterator(this, \"key+value\");\n      }\n\n      forEach(callback) {\n        if (!this || !module.exports.is(this)) {\n          throw new TypeError(\"Illegal invocation\");\n        }\n        if (arguments.length < 1) {\n          throw new TypeError(\n          \"Failed to execute 'forEach' on 'iterable': 1 argument required, \" + \"but only 0 present.\");\n\n        }\n        if (typeof callback !== \"function\") {\n          throw new TypeError(\n          \"Failed to execute 'forEach' on 'iterable': The callback provided \" + \"as parameter 1 is not a function.\");\n\n        }\n        const thisArg = arguments[1];\n        let pairs = Array.from(this[impl]);\n        let i = 0;\n        while (i < pairs.length) {\n          const [key, value] = pairs[i].map(utils.tryWrapperForImpl);\n          callback.call(thisArg, value, key, this);\n          pairs = Array.from(this[impl]);\n          i++;\n        }\n      }}\n\n    Object.defineProperties(URLSearchParams.prototype, {\n      append: { enumerable: true },\n      delete: { enumerable: true },\n      get: { enumerable: true },\n      getAll: { enumerable: true },\n      has: { enumerable: true },\n      set: { enumerable: true },\n      sort: { enumerable: true },\n      toString: { enumerable: true },\n      keys: { enumerable: true },\n      values: { enumerable: true },\n      entries: { enumerable: true },\n      forEach: { enumerable: true },\n      [Symbol.toStringTag]: { value: \"URLSearchParams\", configurable: true },\n      [Symbol.iterator]: { value: URLSearchParams.prototype.entries, configurable: true, writable: true } });\n\n    if (globalObject[ctorRegistry] === undefined) {\n      globalObject[ctorRegistry] = Object.create(null);\n    }\n    globalObject[ctorRegistry][\"URLSearchParams\"] = URLSearchParams;\n\n    Object.defineProperty(globalObject, \"URLSearchParams\", {\n      configurable: true,\n      writable: true,\n      value: URLSearchParams });\n\n  } };\n// iface\nmodule.exports = iface;\n\nconst Impl = require(\"./URLSearchParams-impl.js\");"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}